# Engineering?
## Engineering vs  Science
### 과학
- 순수한 것을 추구
### 공학
- 자원, 과학을 이용하여 인류의 편의를 추구
## 클린코드란 무엇인가?
### 클린코드의 목적
- 보편적인 코딩의 기준은 아니다.
- 이해하기 쉬운 코드
## 패턴

-   알려진 문제의 일반적이고 재사용할 수 있는 해결방법
-   프로그래머는 고유한 문제를 풀어야 한다.
-   고유한 문제는 좀 더 작은 하위 기술 문제를 가진다.
-   이 작은 기술 문제들 중 많은 일부는 과거 어디에 선가 여러 번 반복되 고 해결된 적이 있다.

## 은탄환은 없다.

-   어디에나 쓰이는 만병통치약은 없다.
-   현장은 무균실이 아니라 야전이다.
-   프로그래밍은 협업이다.
    -   서로가 만족하는 코드?보다 중요한것이 무엇일까?
    -   우리가 공유하고있는 목표!
-   시스템은 연결된다.
-   도구 상자에 다양한 도구를 채우자.
    -   완벽한 도구는 없다.
-   엔지니어링은 거래(trade-off)다.

## 근육기억

-   반복되는 문제 해결에 비용이 많이 쓰인다면
-   연습하고, 연습하고, 연습해서 생각의 비용이 줄어들도록 뇌에 새겨라

# 코드기능 명세
## 비즈니스 전문가
- 문제를 가장 잘 알고있는 자
- 해결방법을 잘 알고있는자는 아님

## 분석가
- 비즈니스전문가와 프로그래머를 연결

## 프로그래머

- 정제된 기능 명세를 아키텍처와 코드로 번역
- 끊임없는 설계 결정
- 지식 흐름 과정의 마지막 과정

## 컴퓨터
- 코드를 통해 프로그래머로부터 지식을 전달받음
- 철저히 수동적
- 융통성 없음

# 테스트 기법

## 수동테스트

-   품질 담당자가 UI를 사용해 기능을 검증
-   최종 사용자의 사용 경험과 가장 비슷하게 검증
-   실행 비용이 높고 결과의 변동이 큼
-   가장 온전한 코드 실행
-   인수테스트

## 소프트웨어 회귀(Software regression)

-   A software bug that makes a feature stop functioning as inteded after a certain event
-   소프트웨어의 기능은 시간이 갈수록 늘어난다.
-   회귀 테스트 대상은 시간이 갈수록 늘어난다.
-   수동테스트만으로는 회귀테스트의 대상을 다 커버하기 어렵다!!

## 테스트 자동화

-   기능을 검증하는 코드를 작성
-   테스트 코드 작성 비용이 소비되지만 실행 비용이 낮고 결과의 신뢰도가 높음
-   테스트 코드 작성과 관리가 프로그래머 역량에 크게 영향 받음

## 인수 테스트

-   배치된 시스템을 대상으로 검증
-   전체 시스템 이상 여부 신뢰도가 높음
-   높은 비용
-   피드백 품질이 낮음 (현상은 드러나지만 원인은 숨겨 짐)

## 단위 테스트

-   시스템의 일부(하위 시스템)을 대상으로 검증
-   낮은 비용
-   높은 피드백 품질
-   전체 시스템 이상 여부 신뢰도가 낮음
# 코드분해

## 문제의 크기

-   프로그래머가 한 번에 다룰 수 있는 문제의 크기는 한계를가짐
-   프로그래머는 더 큰 문제를 자주 마주함
-   시스템의 크기는 점점 커짐
-   큰 문제는 작은 문제로 분해할 수 있음
-   작은 문제의 일부는 반복됨

### 한 번 쓰여진 코드는 여러번 읽히게 된다!

→ 코드의 가독성이 프로그래머의 생산성에 영향을 미친다.

## 코드 재사용

-   반복되는 문제의 풀이는 재사용 가능
-   소프트웨어 개발 비용 절감 (엔지니어링)

## 모듈화

### 분해

-   큰 시스템은 더 작은 하위 시스템으로 분해 가능
-   교체 가능

### 조립

-   작은 시스템은 더 큰 상위 시스템으로 조립 가능
-   모듈 재사용
-   라이브러리

# 단위 테스트

- 반복되는 테스트를 할 때, 테스트도 개선이 필요하다.

### Parameterized test

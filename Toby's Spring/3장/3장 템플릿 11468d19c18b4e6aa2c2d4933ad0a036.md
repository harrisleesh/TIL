# 3장 템플릿

# 3.1 다시 보는 초난감 DAO

## 3.1.1 변하는 것과 변하지 않는 것

### JDBC 수정 기능의 예외처리 코드

### JDBC 조회 기능의 예외처리

# 3.2변하는 것과 변하지 않는 것

## 3.2.1 JDBC try/catch/finally 코드의 문제점

## 3.2.2 분리와 재사용을 위한 디자인 패턴 적용

### 메소드 추출

### 템플릿 메소드 패턴의 적용

### 전략 패턴의 적용

### DI 적용을 위한 클라이언트/컨테그스트 분리

# 3.3 JDBC 전략 패턴의 최적화

## 3.3.1 전략 클래스의 추가 정보

## 3.3.2 전략과 클라이언트의 동거

### 로컬 클래스

### 익명 내부 클래스

# 3.4 컨텍스트와 DI

## 3.4.1 JDBCCONTEXT의 분리

### 클래스 분리

### 빈 의존관계 변경

## 3.4.2 JdbcContext의 특별한 DI

### 스프링 빈으로 DI

### 코드를 이용하는 수동 DI

# 3.5 템플릿과 콜백

## 3.5.1 템플릿/콜백의 동작원리

### JdbcContext에 적용된 템플릿/콜백

## 3.5.2 편리한 콜백의 재활용

### 콜백의 분리와 재활용

### 콜백과 템플릿의 결합

## 3.5.3 템플릿/콜백의 응용

### 테스트와 try/catch/finally

### 중복의 제거와 템플릿/콜백 설계

### 템플릿/콜백의 재설계

### 제네릭스를 이용한 콜백 인터페이스

# 3.6 스프링의 JDBCTEMPLATE

## 3.6.1 update()

## 3.6.2 queryForInt()

## 3.6.3 queryForObject()

## 3.6.4 query()

### 기능 정의와 테스트 작성

### query() 템플릿을 이용하는 getAll() 구현

### 테스트 보완

## 3.6.5 재사용 가능한 콜백의 분리

### DI를 위한 코드 정리

### 중복 제거

### 템플릿/콜백 패턴과 UserDao

# 3.7 정리

- JDBC와 같은 예외가 발생할 가능성이 있으며 공유 리소스의 반환이 필요한 코드는 반드시 try/catch/finally 블록으로 관리해야 한다.
- 일정한 작업 흐름이 반복되면서 그중 일부 기능만 바뀌는 코드가 존재한다면 전략 패턴을 적용한다. 바뀌지 않는 부분은 컨텍스트로, 바뀌는 부분은 전략으로 만들고 인터페이스를 통해 유연하게 전략을 변경할 수 있도록 구성한다.
- 같은 애플리케이션 안에서 여러 가지 종류의 전략을 다이내믹하게 구성하고 사용해야 한다면 컨텍스트를 이용하는 클라이언트 메소드에서 직접 전략을 정의하고 제공하게 만든다.
- 클라이언트 메소드 안에 익명 내부 클래스를 사용해서 전략 오브젝트를 구현하면 코드도 간결해지고 메소드의 정보를 직접 사용할 수 있어서 편리하다.
- 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리해서 공유하도록 마는다.
- 컨텍스트는 별도의 빈으로 등록해서 DI 받거나 클라이언트 클래스에서 직접 생성해서 사용한다. 클래스 내부에서 컨텍스트를 사용할 때 컨텍스트가 의존하는 외부의 오브젝트가 있다면 코드를 이용해서 직접 DI 해줄 수 있다.
- 단일 전략 메소드를 갖는 전략 패턴이면서 익명 내부 클래스를 사용해서 매번 전략을 새로 만들어 사용하고, 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식을 템플릿/콜백 패턴이라고 한다.
- 콜백의 코드에도 일정한 패턴이 반복된다면 콜백을 템플릿에 넣고 재활용하는 것이 편리하다.
- 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용한다.
- 스프링은 JDBC 코드 작성을 위해 JdbcTemplate을 기반으로 하는 다양한 템플릿과 콜백을 제공한다.
- 템플릿은 한 번에 하나 이상의 콜백을 사용할 수 있고, 하나의 콜백을 여러 번 호출할 수도 있다.
- 템플릿/콜백을 설계할 때는 템플릿과 콜백 사이에 주고받는 정보에 관심을 둬야 한다.